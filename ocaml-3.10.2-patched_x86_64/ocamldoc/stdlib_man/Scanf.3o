.TH "Scanf" 3 2008-07-16 OCamldoc "OCaml library"
.SH NAME
Scanf \- Formatted input functions.
.SH Module
Module   Scanf
.SH Documentation
.sp
Module
.BI "Scanf"
 : 
.B sig  end

.sp
Formatted input functions\&.
.sp

.sp

.sp
.sp

.pp

.B === 
.B Functional input with format strings\&.
.B  ===

.pp

.pp

.B === The formatted input functions provided by module Scanf are functionals
.B     that apply their function argument to the values they read in the input\&.
.B     The specification of the values to read is simply given by a format string
.B     (the same format strings as those used to print material using module
.B     Printf or module Format)\&.
.B 
.B     As an example, consider the formatted input function scanf that reads
.B     from standard input; a typical call to scanf is simply scanf fmt f,
.B     meaning that f should be applied to the arguments read according to the
.B     format string fmt\&. For instance, if f is defined as let f x = x + 1,
.B     then scanf "%d" f will read a decimal integer i from stdin and return
.B     f i; thus, if we enter 41 at the keyboard, scanf "%d" f evaluates to
.B     42\&.
.B 
.B     This module provides general formatted input functions that read from any
.B     kind of input, including strings, files, or anything that can return
.B     characters\&.
.B     Hence, a typical call to a formatted input function bscan is
.B     bscan ib fmt f, meaning that f should be applied to the arguments
.B     read from input ib, according to the format string fmt\&.
.B 
.B     The Caml scanning facility is reminiscent of the corresponding C feature\&.
.B     However, it is also largely different, simpler, and yet more powerful: the
.B     formatted input functions are higher-order functionals and the parameter
.B     passing mechanism is simply the regular function application not the
.B     variable assigment based mechanism which is typical of formatted input in
.B     imperative languages; the format strings also feature useful additions to
.B     easily define complex tokens; as expected of a functional programming
.B     language feature, the formatted input functions support polymorphism, in
.B     particular arbitrary interaction with polymorphic user-defined scanners\&.
.B     Furthermore, the Caml formatted input facility is fully type-checked at
.B     compile time\&. ===

.pp
.I module Scanning : 
.B sig  end

.sp

.B Scanning buffers

.sp

.sp

.I exception Scan_failure 
.B of 
.B string

.sp
The exception raised by formatted input functions when the input cannot be
read according to the given format\&.
.sp

.sp
.I type 
.B ('a, 'b, 'c, 'd)
.I scanner 
= 
.B ('a, Scanning.scanbuf, 'b, 'c, 'a -> 'd, 'd) format6 -> 'c

.sp
The type of formatted input scanners: 
.B ('a, 'b, 'c, 'd) scanner
is the
type of a formatted input function that reads from some scanning buffer
according to some format string; more precisely, if 
.B scan
is some
formatted input function, then 
.B scan ib fmt f
applies 
.B f
to the arguments
specified by the format string 
.B fmt
, when 
.B scan
has read those arguments
from some scanning buffer 
.B ib
\&.
.sp
For instance, the 
.B scanf
function below has type 
.B ('a, 'b, 'c, 'd)
.B     scanner
, since it is a formatted input function that reads from 
.B stdib
:
.B scanf fmt f
applies 
.B f
to the arguments specified by 
.B fmt
, reading
those arguments from 
.B stdin
as expected\&.
.sp
If the format 
.B fmt
has some 
.B %r
indications, the corresponding input
functions must be provided before the 
.B f
argument\&. For instance, if
.B read_elem
is an input function for values of type 
.B t
, then 
.B bscanf ib
.B     "%r;" read_elem f
reads a value of type 
.B t
followed by a 
.B ';'
character\&.
.sp

.sp

.pp

.B === 
.B Formatted input functions
.B  ===

.pp

.I val bscanf 
: 
.B Scanning.scanbuf -> ('a, 'b, 'c, 'd) scanner
.sp

.B bscanf ib fmt r1 \&.\&.\&. rN f
reads arguments for the function 
.B f
from the
scanning buffer 
.B ib
according to the format string 
.B fmt
, and applies 
.B f
to these values\&.
The result of this call to 
.B f
is returned as the result of 
.B bscanf
\&.
For instance, if 
.B f
is the function 
.B fun s i -> i + 1
, then
.B Scanf\&.sscanf "x = 1" "%s = %i" f
returns 
.B 2
\&.
.sp
Arguments 
.B r1
to 
.B rN
are user-defined input functions that read the
argument corresponding to a 
.B %r
conversion\&.
.sp
The format is a character string which contains three types of
objects:
.sp
\-plain characters, which are simply matched with the characters of the
input,
.sp
\-conversion specifications, each of which causes reading and conversion of
one argument for 
.B f
,
.sp
\-scanning indications to specify boundaries of tokens\&.

Among plain characters the space character (ASCII code 32) has a
special meaning: it matches ``whitespace'', that is any number of tab,
space, line feed and carriage return characters\&. Hence, a space in the format
matches any amount of whitespace in the input\&.
.sp
Conversion specifications consist in the 
.B %
character, followed by
an optional flag, an optional field width, and followed by one or
two conversion characters\&. The conversion characters and their
meanings are:
.sp
.sp
\-
.B d
: reads an optionally signed decimal integer\&.
.sp
\-
.B i
: reads an optionally signed integer
(usual input formats for hexadecimal (
.B 0x[d]+
and 
.B 0X[d]+
),
octal (
.B 0o[d]+
), and binary 
.B 0b[d]+
notations are understood)\&.
.sp
\-
.B u
: reads an unsigned decimal integer\&.
.sp
\-
.B x
or 
.B X
: reads an unsigned hexadecimal integer\&.
.sp
\-
.B o
: reads an unsigned octal integer\&.
.sp
\-
.B s
: reads a string argument that spreads as much as possible,
until the next white space, the next scanning indication, or the
end-of-input is reached\&. Hence, this conversion always succeeds:
it returns an empty string if the bounding condition holds
when the scan begins\&.
.sp
\-
.B S
: reads a delimited string argument (delimiters and special
escaped characters follow the lexical conventions of Caml)\&.
.sp
\-
.B c
: reads a single character\&. To test the current input character
without reading it, specify a null field width, i\&.e\&. use
specification 
.B %0c
\&. Raise 
.B Invalid_argument
, if the field width
specification is greater than 1\&.
.sp
\-
.B C
: reads a single delimited character (delimiters and special
escaped characters follow the lexical conventions of Caml)\&.
.sp
\-
.B f
, 
.B e
, 
.B E
, 
.B g
, 
.B G
: reads an optionally signed
floating-point number in decimal notation, in the style 
.B dddd\&.ddd
.B      e/E+-dd
\&.
.sp
\-
.B F
: reads a floating point number according to the lexical
conventions of Caml (hence the decimal point is mandatory if the
exponent part is not mentioned)\&.
.sp
\-
.B B
: reads a boolean argument (
.B true
or 
.B false
)\&.
.sp
\-
.B b
: reads a boolean argument (for backward compatibility; do not use
in new programs)\&.
.sp
\-
.B ld
, 
.B li
, 
.B lu
, 
.B lx
, 
.B lX
, 
.B lo
: reads an 
.B int32
argument to
the format specified by the second letter (decimal, hexadecimal, etc)\&.
.sp
\-
.B nd
, 
.B ni
, 
.B nu
, 
.B nx
, 
.B nX
, 
.B no
: reads a 
.B nativeint
argument to
the format specified by the second letter\&.
.sp
\-
.B Ld
, 
.B Li
, 
.B Lu
, 
.B Lx
, 
.B LX
, 
.B Lo
: reads an 
.B int64
argument to
the format specified by the second letter\&.
.sp
\-
.B [ range ]
: reads characters that matches one of the characters
mentioned in the range of characters 
.B range
(or not mentioned in
it, if the range starts with 
.B ^
)\&. Reads a 
.B string
that can be
empty, if the next input character does not match the range\&. The set of
characters from 
.B c1
to 
.B c2
(inclusively) is denoted by 
.B c1-c2
\&.
Hence, 
.B %[0-9]
returns a string representing a decimal number
or an empty string if no decimal digit is found; similarly,
.B %[\(rs\(rs048-\(rs\(rs057\(rs\(rs065-\(rs\(rs070]
returns a string of hexadecimal digits\&.
If a closing bracket appears in a range, it must occur as the
first character of the range (or just after the 
.B ^
in case of
range negation); hence 
.B []]
matches a 
.B ]
character and
.B [^]]
matches any character that is not 
.B ]
\&.
.sp
\-
.B r
: user-defined reader\&. Takes the next 
.B ri
formatted input function and
applies it to the scanning buffer 
.B ib
to read the next argument\&. The
input function 
.B ri
must therefore have type 
.B Scanning\&.scanbuf -> 'a
and
the argument read has type 
.B 'a
\&.
.sp
\-
.B { fmt %}
: reads a format string argument to the format
specified by the internal format 
.B fmt
\&. The format string to be
read must have the same type as the internal format 
.B fmt
\&.
For instance, "%{%i%}" reads any format string that can read a value of
type 
.B int
; hence 
.B Scanf\&.sscanf "fmt:\(rs\(rs\(rs"number is %u\(rs\(rs\(rs"" "fmt:%{%i%}"
succeeds and returns the format string 
.B "number is %u"
\&.
.sp
\-
.B \(rs( fmt %\(rs)
: scanning format substitution\&.
Reads a format string to replace 
.B fmt
\&. The format string read
must have the same type as 
.B fmt
\&.
.sp
\-
.B l
: returns the number of lines read so far\&.
.sp
\-
.B n
: returns the number of characters read so far\&.
.sp
\-
.B N
or 
.B L
: returns the number of tokens read so far\&.
.sp
\-
.B !
: matches the end of input condition\&.
.sp
\-
.B %
: matches one 
.B %
character in the input\&.

Following the 
.B %
character that introduces a conversion, there may be
the special flag 
.B _
: the conversion that follows occurs as usual,
but the resulting value is discarded\&.
For instance, if 
.B f
is the function 
.B fun i -> i + 1
, then
.B Scanf\&.sscanf "x = 1" "%_s = %i" f
returns 
.B 2
\&.
.sp
The field width is composed of an optional integer literal
indicating the maximal width of the token to read\&.
For instance, 
.B %6d
reads an integer, having at most 6 decimal digits;
.B %4f
reads a float with at most 4 characters; and 
.B %8[\(rs\(rs000-\(rs\(rs255]
returns the next 8 characters (or all the characters still available,
if fewer than 8 characters are available in the input)\&.
.sp
Scanning indications appear just after the string conversions 
.B %s
and 
.B %[ range ]
to delimit the end of the token\&. A scanning
indication is introduced by a 
.B @
character, followed by some
constant character 
.B c
\&. It means that the string token should end
just before the next matching 
.B c
(which is skipped)\&. If no 
.B c
character is encountered, the string token spreads as much as
possible\&. For instance, 
.B "%s@\(rst"
reads a string up to the next
tab character or to the end of input\&. If a scanning
indication 
.B @c
does not follow a string conversion, it is treated
as a plain 
.B c
character\&.
.sp
Raise 
.B Scanf\&.Scan_failure
if the input does not match the format\&.
.sp
Raise 
.B Failure
if a conversion to a number is not possible\&.
.sp
Raise 
.B End_of_file
if the end of input is encountered while some more
characters are needed to read the current conversion specification\&.
As a consequence, scanning a 
.B %s
conversion never raises exception
.B End_of_file
: if the end of input is reached the conversion succeeds and
simply returns the characters read so far, or 
.B ""
if none were read\&.
.sp
Raise 
.B Invalid_argument
if the format string is invalid\&.
.sp
Notes:
.sp
.sp
\-the scanning indications introduce slight differences in the
syntax of 
.B Scanf
format strings compared to those used by the
.B Printf
module\&. However, scanning indications are similar to those
of the 
.B Format
module; hence, when producing formatted text to be
scanned by 
.B !Scanf\&.bscanf
, it is wise to use printing functions
from 
.B Format
(or, if you need to use functions from 
.B Printf
,
banish or carefully double check the format strings that contain
.B '@'
characters)\&.

.sp
\-in addition to relevant digits, 
.B '_'
characters may appear
inside numbers (this is reminiscent to the usual Caml lexical
conventions)\&. If stricter scanning is desired, use the range
conversion facility instead of the number conversions\&.

.sp
\-the 
.B scanf
facility is not intended for heavy duty lexical
analysis and parsing\&. If it appears not expressive enough for your
needs, several alternative exists: regular expressions (module
.B Str
), stream parsers, 
.B ocamllex
-generated lexers,
.B ocamlyacc
-generated parsers\&.

.sp

.sp

.I val fscanf 
: 
.B Pervasives.in_channel -> ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but reads from the given channel\&.
.sp
Warning: since all formatted input functions operate from a scanning
buffer, be aware that each 
.B fscanf
invocation must allocate a new
fresh scanning buffer (unless you make careful use of partial
application)\&. Hence, there are chances that some characters seem
to be skipped (in fact they are pending in the previously used
scanning buffer)\&. This happens in particular when calling 
.B fscanf
again
after a scan involving a format that necessitated some look ahead
(such as a format that ends by skipping whitespace in the input)\&.
.sp
To avoid confusion, consider using 
.B bscanf
with an explicitly
created scanning buffer\&. Use for instance 
.B Scanning\&.from_file f
to allocate the scanning buffer reading from file 
.B f
\&.
.sp
This method is not only clearer it is also faster, since scanning
buffers to files are optimized for fast buffered reading\&.
.sp

.sp

.I val sscanf 
: 
.B string -> ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but reads from the given string\&.
.sp

.sp

.I val scanf 
: 
.B ('a, 'b, 'c, 'd) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but reads from the predefined scanning
buffer 
.B Scanf\&.Scanning\&.stdib
that is connected to 
.B stdin
\&.
.sp

.sp

.I val kscanf 
: 
.B Scanning.scanbuf ->
.B   (Scanning.scanbuf -> exn -> 'a) -> ('b, 'c, 'd, 'a) scanner
.sp
Same as 
.B Scanf\&.bscanf
, but takes an additional function argument
.B ef
that is called in case of error: if the scanning process or
some conversion fails, the scanning function aborts and calls the
error handling function 
.B ef
with the scanning buffer and the
exception that aborted the scanning process\&.
.sp

.sp

.I val bscanf_format 
: 
.B Scanning.scanbuf ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g
.sp

.B bscanf_format ib fmt f
reads a format string token from the scannning
buffer 
.B ib
, according to the given format string 
.B fmt
, and applies 
.B f
to
the resulting format string value\&.
Raise 
.B Scan_failure
if the format string value read doesn't have the
same type as 
.B fmt
\&.
.sp

.sp

.I val sscanf_format 
: 
.B string ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6 ->
.B   (('a, 'b, 'c, 'd, 'e, 'f) format6 -> 'g) -> 'g
.sp
Same as 
.B Scanf\&.bscanf_format
, but reads from the given string\&.
.sp

.sp

.I val format_from_string 
: 
.B string ->
.B   ('a, 'b, 'c, 'd, 'e, 'f) format6 -> ('a, 'b, 'c, 'd, 'e, 'f) format6
.sp

.B format_from_string s fmt
converts a string argument to a format string,
according to the given format string 
.B fmt
\&.
Raise 
.B Scan_failure
if 
.B s
, considered as a format string, doesn't
have the same type as 
.B fmt
\&.
.sp

.sp
