open Data_structures
open Pb_sig 
open Tools 

type template_piece = {kept_sites:StringSet.t}

type ode_skeletons = 
    {subviews:(template_piece list) StringMap.t;
      passing_sites: String2Set.t}

let p_string = print_string 
let p_newline = print_newline 
let p_int = print_int 
let p_float = print_float 

type expr = 
    Letter of string 
  |   Var of int |
    Mult of (expr*expr)
  | Div of (expr*expr)
  | Eps 
  | Plus of (expr*expr)
  | Const of int 
  | Constf of float 

let equal_un expr = 
  match expr with 
    Const 1 | Constf 1. -> true 
  | _ -> false

let equal_zero expr = 
  match expr with 
    Const 0 | Constf 0. -> true 
  | _ -> false 

let rec simplify_expr (expr:expr) = 
  match expr with 
   
    Plus (a,x) when equal_zero a -> simplify_expr x
    | Plus(x,a) when equal_zero a -> simplify_expr x
    | Mult(a,x) when equal_un a -> simplify_expr x
    | Mult(x,a) when equal_un a -> simplify_expr x 
    | Div(x,a) when equal_un a -> simplify_expr x 
  | Plus (x,y) -> 
      Plus(simplify_expr x,simplify_expr y)
  | Mult (x,y) -> 
      let x = simplify_expr x in
      let y = simplify_expr y in
      if x=Const 1 then y 
      else if y=Const 1 then x 
      else Mult(x,y)
  | Div  (x,y) -> 
      let x = simplify_expr x in
      let y = simplify_expr y in
      if x=y 
      then Const 1
      else Div(x,y)
  | Constf a when float_of_int(int_of_float a)=a -> Const (int_of_float a)
  | _ -> expr

let is_atomic expr = 
  match expr with 
   Letter _ | Eps | Var _ -> true
   | Constf f -> f>= 0.
   | Const a -> a>=0 
 | _ -> false 

let rec print_expr print_string print_int print_float x = 
  match x with
    Constf f -> print_float f
  |    Letter s -> print_string s
  | 
    Const i -> print_int i 
  | Var i -> (print_string "y(";print_int i;print_string ")")
  | Div (a,b) -> (print_atom print_string print_int print_float a;print_string "/";print_atom print_string print_int print_float b)
  | Mult (a,b) -> (print_atom print_string print_int print_float a;print_string "*";print_atom print_string print_int print_float b)
  | Plus (a,b) -> (print_atom print_string print_int print_float a;print_string "+";print_atom print_string print_int print_float b)
  | Eps -> print_string  "e"
and print_atom print_string print_int print_float x = 
  if is_atomic x then print_expr print_string print_int print_float x 
  else (print_string "(";print_expr print_string print_int print_float x;print_string ")")
  



type posneg = Creation | Suppression

type update = 
    {target:int;
     rate:expr}
     


let dump_template x =
  let _ = print_string "Passing sites:" in
  let _ = print_newline () in
  let _ = 
    String2Set.iter
      (fun (a,b) -> print_string a;print_string ".";print_string b;print_newline ())
      x.passing_sites in
  let _ = print_newline () in
  let _ = print_string "Templates:" in
  let _ = print_newline () in
  let _ = print_newline () in 
  let _ = 
    StringMap.iter 
      (fun x l -> 
	let _ = print_string "Agent: " in
	let _ = print_string x in
	let _ = print_newline () in
	let _ = 
	  List.iter 
	    (fun x -> 
	        let _ = print_string "Template" in
		let _ = print_newline () in 
	      	let _ = print_string "Sites" in
		let _ = print_newline () in 
		let _ = 
		  StringSet.iter 
		    (fun x -> 
		      print_string x;
		      print_string ",")
		    x.kept_sites in
		let _ = print_newline () in 
		let _ = print_newline () in
		let _ = print_newline () in 
		())
	    l in
	let _ = print_newline () 
	in ())
      x.subviews 
  in ()

let sub_template a b = 
  StringSet.subset a.kept_sites b.kept_sites 
  


  
let compute_templates file_ODE file_alphabet prefix log pb pb_boolean_encoding subviews (project,export_ae,restore,b_of_var,var_of_b,print_sb,fnd_of_bdd,conj,atom_pos,atom_neg,expr_true) (l,m) = 
  let print_string,print_newline,print_int,print_float,chan = 
    if file_ODE<>""
    then 
      let chan = open_out file_ODE in
      let print_string x = Printf.fprintf chan "%s" x in
      let print_newline () = Printf.fprintf chan "\n" in
      let print_int i = Printf.fprintf chan "%d" i in
      let print_float i = Printf.fprintf chan "%f" i in 
      print_string,print_newline,print_int,print_float,Some chan 
    else
      print_string,print_newline,print_int,print_float,None in 
  let print_string2,print_newline2,print_int2,print_float2,chan2 = 
    if file_alphabet<>""
    then 
      let chan = open_out file_alphabet in
      let print_string x = Printf.fprintf chan "%s" x in
      let print_newline () = Printf.fprintf chan "\n" in
      let print_int i = Printf.fprintf chan "%d" i in
      let print_float i = Printf.fprintf chan "%f" i in 
      print_string,print_newline,print_int,print_float,Some chan 
    else
      print_string,print_newline,print_int,print_float,None in 
		
  let hash_tp_list,dump = 
    let n = ref 1 in
    let map = ref IntListMap.empty in
    let rec f init x =
      let _ = print_string "HASH" in
      let _ = print_string (if init then "T\n" else "F\n") in 
      if init then 
	let x' = List.sort compare x in
	try ([IntListMap.find x' (!map)])
	with Not_found -> 
	  let rep = (!n) in
	  let _ = n:= (!n)+1 in
	let _ = map:=IntListMap.add x' rep (!map) in
	[rep]
      else 
	(let x' = List.sort compare x in
	try [IntListMap.find x' (!map)] 
	with 
	  Not_found -> 
	    let rec sublist l = 
	      List.fold_left 
		(fun prefix_list a -> 
		  (List.map (fun (q,q') -> (q,a::q')) prefix_list)@(List.map (fun (q,q') -> (a::q,q')) prefix_list))
		[[],[]] l in
	    let a = List.map (fun (x,y) ->List.sort compare x,List.sort compare y) (sublist x) in
	    let rec aux q best n = 
	      match q with [] -> best 
	      | (t,t')::q -> 
		  if 
		    try (let _ = IntListMap.find t (!map) in true)
		    with _ -> false
		  then
		    let n' = List.length t in
		    if List.length t>n
		    then 
		      aux q (t,t') n' 
		    else 
		      aux q best n 
		  else
		    aux q best n in
	    let max_prefix,residue = aux a ([],x) 0 in
	    if max_prefix = [] 
	    then 
	      if residue = [] 
	      then []
	      else 
		let _ = IntListMap.iter 
		  (fun l i -> 
		    List.iter print_int l;
		    print_string ":";
		    print_int i;
		    print_newline ()) 
		  (!map) in 
		let _ = List.iter print_int x in 
		unsafe_frozen "Template 205" (fun () -> raise Exit)
	    else
	      if residue = [] 
	      then []
	      else 
		(IntListMap.find max_prefix (!map))::(f false residue))
	  
  in f,
    let dump fmap  = 
      let l = 
	IntListMap.fold
	  (fun l n list -> 
	    ((n,
	      let expr = 
	      List.fold_left (fun expr x -> 
		let (a,(x:string),(xx:template_piece),(d:String4Set.t)) = 
		  Intmap.find x fmap in
		(StringMap.add x 
		   (List.fold_left 
		      (fun expr (y,z) ->
			conj expr
			  ((if z then atom_pos else atom_neg) ( y)))
		      (atom_pos (var_of_b (H(x,x))))
		      a)
		   expr)) 
		  StringMap.empty l in
	      expr)::list)) (!map) [] in
      let l = List.sort (fun (a,b) (c,d) -> compare a c) l in
      let _ = List.iter 
	  (fun (n,expr) -> 
	    print_string "y(";print_int n;print_string "):=";
	    let _ = 
	    print_sb expr
		pb 
		(chan)
	    in 
	    print_newline ())
	l in 
      () in dump 
  in
  let dump_prod prod  = 
    Intmap.iter  
      (fun k b -> 
	print_string "dy(";
	print_int k;
	print_string "):=";
	let _ = List.fold_left 
			(fun bool (a,b) ->
			  let _ = 
			    if bool then print_string "+"
			    else 
			      () in
			  print_expr print_string print_int print_float (simplify_expr (Mult(Const a,b)));
			  true) 
	    false b in print_newline ()) 
      prod  in 
  let is_access = 
    match pb.unreachable_rules with 
      None -> (fun x -> true)
    | Some a -> (fun x -> not (RuleIdSet.mem x a)) in 
(*  let prefix' = prefix^"-" in*)
  let a = pb_boolean_encoding in 
  let clean rs = 
    let rs = 
      {rs with rules = 
	List.rev 
	  (
	List.fold_left  
	  (fun sol x -> 
	    let lab = List.filter (fun a -> not a.r_clone &&  (is_access a)) x.labels in
	    if lab = [] then sol
	    else ({x with labels = lab})::sol)
	  [] rs.rules)} in 
    rs in 
  let simplify rs = 
    let a = rs.Pb_sig.passive_species in 
    let pass,forget_agents = 
      List.fold_left 
	(fun (pass,forget_agents) ((a,b,c),(d,e,f))->
	  if List.exists 
	      (fun rule -> 
		List.exists 
		  (fun test ->
		    match test with 
			M((a',b',_),_),_ when (a,b)=(a',b') -> true
		      | B(a',b',c'),_ | AL((a',b',c'),_),_ 
		      | L((a',b',c'),_),_  when (a,b)=(a',b') && c'<>c -> true
		      | L(_,(a',b',c')),_  when (a,b)=(a',b') && c'<>c -> true 
		      | _ -> false
		    ) rule.Pb_sig.injective_guard)
	      rs.Pb_sig.rules
	  then 
	    ((a,b,c),(d,e,f))::pass,forget_agents
	  else
	    (pass,StringSet.add a forget_agents))
	([],StringSet.empty) a in
    {rs with 
      Pb_sig.passive_species = pass ;
      Pb_sig.rules = 
      List.map 
	(fun r -> {r 
	      with Pb_sig.injective_guard = 
		List.filter 
		  (fun x ->
		    match x with 
		      H(a,_),_ | 
		      B(a,_,_),_ | AL((a,_,_),_),_ | M((a,_,_),_),_ -> 
			not (StringSet.mem a forget_agents)
		    | L((a,_,_),(b,_,_)),_ -> 
			not (StringSet.mem a forget_agents) && 
			not (StringSet.mem b forget_agents)
		    | _ -> false)
		  r.Pb_sig.injective_guard
	      })	
	rs.Pb_sig.rules } in 
  let system = List.map (fun x -> simplify (clean x)) a.Pb_sig.system in 
      
  begin
    let rep = 
      List.fold_left  
	(fun (sol,passing_sites) rs ->
	  let passive = rs.Pb_sig.passive_species in 
	  let passing_sites = 
	    List.fold_left 
	      (fun sol ((a,b,c),(d,e,f)) ->
		let fadd x y  sol = 
		  if 
		    List.exists 
		      (fun a -> 
			(List.exists 
			   (fun b -> 
			     match b with 
			       M((a',b',_),_),_ when x=(a',b') -> true
			     | B(a',b',c'),_ | AL((a',b',c'),_),_ when x=(a',b') && c'<>y -> true 
			     | L((a',b',c'),_),_ when x=(a',b') && c'<>y -> true 
			     | L(_,(a',b',c')),_  when x=(a',b') && c'<>y -> true 
			     | _ -> false
				   ) a.Pb_sig.injective_guard)) rs.Pb_sig.rules 
		  then 
		    String2Set.add (snd x,y) sol
		  else
		    sol
		in
		
		fadd (a,b) c (fadd (d,e) f passing_sites))
	      passing_sites passive in
	  let local_map  = 
	    List.fold_left 
	      (fun sol a ->
			List.fold_left 
		  (fun sol a -> 
		    
		    let fadd x y sol = 
		      let old' = 
			try String2Map.find x sol 
			with 
				  Not_found -> StringSet.empty 
		      in
		      String2Map.add x 
			(StringSet.add y old') sol in
		    match a with
		      H (x,x'),true -> 
			(try 
			  (String2Map.find (x,x') sol;sol)
		        with 
			  Not_found -> 
			    (String2Map.add (x,x') StringSet.empty sol))
		    |  H _,_ -> sol
		    | Connected _,_ -> sol 
		    |  B(a,a',b),_ ->  fadd (a,a') b sol
		    | AL((a,a',b),_),_ -> fadd (a,a') b sol
		    | L((a,a',b),(c,c',d)),_ -> fadd (a,a') b (fadd (c,c') d sol)
		    | M((a,a',b),c),_ -> fadd (a,a') b sol)
		  sol a.Pb_sig.injective_guard)
	      String2Map.empty rs.Pb_sig.rules
	  in  
	  String2Map.fold
	    (fun (_,a) b sol ->
	      let old = 
		try StringMap.find a sol 
		with Not_found -> [] 
	      in
	      StringMap.add a ({kept_sites=b}::old) sol)
	    local_map sol,passing_sites 
	    )			  
	(StringMap.empty,String2Set.empty)
	system
    in
    let system = List.map clean a.Pb_sig.system in  
    let rep = 
      {subviews=
	StringMap.map
	  (fun b -> 
	    let rec aux a b = 
	      match a with [] -> b
	      | t::q -> 
		  if List.exists (fun a' -> sub_template t a') q or 
		    List.exists (fun a' -> sub_template t a') b 
		  then aux q b
		  else aux q (t::b)
	    in aux b []
	      )
	  
	  (fst rep) ;
	passing_sites = snd rep}
	    in 
  (*  let _ = print_option  prefix' log "Compute valuation" in*)
(*    let _ = dump_template rep in *)
    let rep2  = 
      StringMap.fold
	(fun a tp  sol  ->
	  List.fold_left
	    (fun sol sites -> 
	      let g x = 
		match b_of_var x
		with M((_,_,y),_) 
		| B(_,_,y)
		| AL((_,_,y),_)  -> StringSet.mem y sites.kept_sites
		| _ -> false in
	      let l = 
		try 
 		  let res = (project 
			       (conj 
				  (atom_pos (var_of_b (H(a,a)))) 
				  (restore (StringMap.find a subviews)
				 ))
			   g) in
	      	  let sb =  fnd_of_bdd res in
		  List.map (fun x -> (a,sites,x)) sb 
		with Not_found -> [] in
	      l@sol)
	    sol tp )
	rep.subviews
        [] in
    let _ = 
      if false  then 
	let _ = print_string "VARIABLES\n" in 
	let _ = 
	  List.iter 
	    (fun (x,y,a) -> 
	      let _ = print_newline () in 
	      let _ = print_string "AGENT: " in
	      let _ = print_string x in
	      let _ = print_newline () in 
	      let _ = print_string "SITES: " in
	      let _ = 
		StringSet.iter  (fun x-> print_string x;print_string ", ") y.kept_sites  in  
	      let _ = 
	    List.iter 
		  (fun (b,bool) ->
		    print_b (b_of_var b);
		    print_string (if bool then "TRUE" else "FALSE");
		    print_newline ())
		  a in ())
	    rep2
	in () in
    let gather rep2 = 
      List.fold_left  
	(fun (interface_map,link_to_template,blist_to_template,n) (x,s,a) -> 
	  let int = 
	    List.fold_left 
	      (fun sol (b,bool) -> 
		match b_of_var b,bool with 
		  AL((a,b,c),(d,e)),true 
		  when String2Set.mem (a,c) rep.passing_sites
		      && String2Set.mem (d,e) rep.passing_sites 
		  -> 
		    String4Set.add ((a,c),(d,e)) sol 
		| _ -> sol) 
	      String4Set.empty  a in
	  let interface_map = Intmap.add n (a,x,s,int) interface_map in
	  let link_to_template =
	    String4Set.fold
	      (fun x link_to_template -> 
		let old = 
		  try 
		    String4Map.find x link_to_template
		  with Not_found 
		    -> [] 
		in
		String4Map.add x (n::old) link_to_template)
	      int 
	      link_to_template 
	  in
	  let blist_to_template = 
	    StringBListMap.add (x,(List.sort compare 
				     (List.map (fun (b,b2) -> (b_of_var b,b2)) a))) n blist_to_template in 
	  
	  (interface_map,link_to_template,blist_to_template,n+1)
	    )
	(Intmap.empty,String4Map.empty,StringBListMap.empty,1) 
	rep2 
    in 
    let int_map,link_to_temp,blist_to_template,n = gather rep2 in
    let agent_to_int_to_nlist = 
      Intmap.fold 
	(fun n (a,x,s,int) sol ->
	  let l = List.rev (StringSet.fold (fun x l -> x::l) s.kept_sites []) in
	  let old = 
	    try StringMap.find x sol 
	    with Not_found -> StringListMap.empty 
	  in
	  let old2 = 
	    try StringListMap.find l old
	    with Not_found -> [] in
	  StringMap.add x 
	    (StringListMap.add l (n::old2) old) 
	    sol)
	int_map StringMap.empty in
    let agent_to_int_to_nlist = 
      StringMap.map 
	(fun map -> 
	  let add l n map = 
	    try 
	      let _ =
		StringListMap.find l map in
	      map 
	    with 
	      Not_found -> 
		StringListMap.add l n map in
	  StringListMap.fold 
	    (fun l n map -> 
	      List.fold_left
		(fun map l' -> add l' n map)
		map 
		(sublist 
		   l))
	    map map )
	agent_to_int_to_nlist in
    let _ =
      if false then 
	let _ = 
	  print_string "AGENT_to_INT_to_nlist\n" in
	StringMap.iter 
	  (fun s map ->
	    print_string s;
	    print_newline ();
	  StringListMap.iter 
	      (fun s n -> 
		List.iter (fun x->print_string x;print_string ",") s;
		print_newline ();
	      List.iter (fun n -> print_int n;print_string ",") n;
		print_newline ())
	      map)
	  agent_to_int_to_nlist 
    in 
    let rep3 = 
      let rec aux l sol = 
	match l with 
	  [] -> sol
	| 
	  (agents,b,tp_list,set,forbid,nmax)::q when String4Set.is_empty set -> aux q ((agents,List.sort compare b,List.sort compare tp_list)::sol)
	| (agents,blist,tp_list,set,forbid,nmax)::q ->
	    let (a,b) = String4Set.min_elt set in
	    let set' = String4Set.remove (a,b) set in 
	    let asso_list  = 
	      try 
		String4Map.find (b,a) link_to_temp
	      with 
		_ -> [] in
	    let q' = 
	      List.fold_left 
		(fun sol m ->
		  if m<nmax then sol
		  else
		    let blist',x,s,int = 
		      try 
		      Intmap.find m int_map 
		    with Not_found -> unsafe_frozen "TEMPLATE 348" (fun () -> raise Exit) in
		    if StringSet.mem x forbid then 
		      (agents,blist,tp_list,set',forbid,nmax)::sol
								 
		    else
		      
		    let int = 
		      String4Set.remove (b,a) int in 
		    (m::agents,blist'@blist,
		     (x,s)::tp_list,String4Set.union int set'
		       , StringSet.add x forbid,nmax)::sol
		  )
		q asso_list
	    in
	    aux q' sol 
      in aux 
	(Intmap.fold 
	   (fun a (b,x,s,c) list ->
	     ([a],b,[x,s],c,StringSet.singleton x,a)::list)
	   int_map [])
	[] in 
    let _ = 
      if false  then 
	List.iter 
	  (fun (a,b,tp) ->
	    let _ = 
	      List.iter (fun (s,x) -> 
		print_string s;
		print_string "(";
		StringSet.iter 
		  (fun x -> print_string x;print_string ",")
		   x.kept_sites;
		print_string ")")
		tp in 
	    let _ = print_newline () in 
	    let _ = List.iter (fun (a,b) -> print_b (b_of_var a);print_string (if b then ":T," else ":F,")) b in 
	    let _ = print_newline () in
	    let _ = print_newline () in 
	    ()) 
	  rep3 in 
(*    let _ = print_option prefix' log "compute activity" in*)
(*    let prefix'' = prefix'^"-" in*)
    let activity = 
      List.map 
	(fun x -> 
	  let control = x.Pb_sig.control in 
	  let passives = x.Pb_sig.passive_species in 
	  let specie_of_id y = 
	    try 
	      StringMap.find y x.Pb_sig.specie_of_id
	    with 
	      Not_found -> 
		y in
	  let classes = 
	    List.map  
	      (fun xx -> 
		StringSet.fold 
		  (fun x l ->
		    let rec aux to_visit black set = 
		      match to_visit with 
			[] -> set
		      | 
			t::q -> 
			  let rec aux2 l to_visit black =
			    match l with 
			      ((a,a',_),(b,b',_))::q
			      when b=t && not (StringSet.mem a black)  
			      -> aux2 q (a::to_visit) (StringSet.add a black) 
			    | t::q -> aux2 q to_visit black 
			    | [] -> to_visit,black 
			  in
			  let tv,b = aux2 passives q black in
			  aux tv b (StringSet.add t set) in
		    (xx,aux [x] (StringSet.empty) (StringSet.singleton x))::l) 
		  (List.fold_left 
		     (fun set ((a',_,_),_) -> 
		       StringSet.remove a' set)
		     xx.Pb_sig.target passives) [])
	      x.Pb_sig.rules
	  in
	  let classes = 
	    List.map 
	      (fun x -> 
		List.map 
		  (fun (xx,cla) -> 
		    let blist =  (List.filter 
		       (fun x -> 
			 match x with 
			   B(a,_,_),_ | AL((a,_,_),_),_ | M((a,_,_),_),_ when StringSet.mem a cla -> true 
			 | L((a,_,_),(b,_,_)),_ when StringSet.mem a cla or StringSet.mem b cla -> true
			 | _ -> false)
		       xx.Pb_sig.injective_guard) in
		    (xx,cla,blist,
		     List.fold_left 
		       (fun map (b,bool) -> 
			 match b with 
			   B(_,a,b) -> BMap.add (B(a,a,b)) bool map
			 | AL((a,b,c),d) -> BMap.add (AL((b,b,c),d)) bool map
			 | L((_,b,c),(_,d,e)) -> 
			     if bool then 
			       BMap.add (AL((b,b,c),(d,e))) bool
				 (BMap.add (AL((d,d,e),(b,c))) bool map)
			       else
			       unsafe_frozen "template 468" (fun () -> raise Exit)
			 | M((_,a,b),c) -> BMap.add (M((a,a,b),c)) bool map
			 | _ -> map) 
		       BMap.empty 
		       blist 
		       ))  x) classes in 
	  let classes = 
	    List.map 
	      (fun x -> 
		(List.map 
		   (fun (rule,agentset,blist,bmap) -> 
		     let roots = 
		  List.fold_left
			 (fun set ((a,_,_),(a',_,_)) -> 
			   if StringSet.mem a' agentset 
			   then 
			     StringSet.remove a set 
			   else 
			     set )
			 agentset passives in
		     (rule,agentset,blist,bmap,roots)) x))
	      classes 
	  in
	 
	  let classes = 
	    List.map 
	      (fun x -> 
		(List.map 
		   (fun (rule,agentset,blist,bmap,roots) -> 
		     if not (StringSet.cardinal roots=1)
		     then frozen_unsafe "BUG in template 470" (fun () -> raise Exit)
		     else
		       let root = StringSet.min_elt roots in
		       let rec aux l  sol = 
			 match l with 
			   [] -> sol
			 | (guard,to_visit_same_class,to_visit_other_class,black,(prefix:int list),same_class_agent,other_class)::q -> 
			     begin
			       match to_visit_same_class with 
				 [] -> 
				   begin
				     match to_visit_other_class 
				     with [] -> 
				       aux q (((guard,prefix,same_class_agent)::other_class)::sol)
				     | (g,a)::b -> 
					 aux (((g,[a],b,black,[],[],(guard,prefix,same_class_agent)::other_class))::q) sol 
				   end

			       | a::b -> 
				   if StringSet.mem a black  or  not (List.exists (fun x -> match x with H(x,_),b -> (
				     (x=a && b)) | 
				     _  -> false) rule.Pb_sig.injective_guard) 
				   then 
				     ( aux ((guard,b,to_visit_other_class,black,prefix,same_class_agent,other_class)::q) sol)
				   else
				     let restricted_blist = 
				       List.filter 
					 (fun (b,bool) -> 
					   match b with 
					     B(b',_,_) | AL((b',_,_),_) | M((b',_,_),_) when b' = a -> true 
					   | L((b',_,_),(c',_,_)) when b'=a or c'=a -> true 
					   | _ -> false)
					 blist in
				     let site_list,_ = 
				       List.fold_left
					 (fun (sol,black) (b,bool) -> 
					   match b with 
					     B(_,_,s) | AL((_,_,s),_) | M((_,_,s),_) -> if StringSet.mem s black then (sol,black) else
					     s::sol,StringSet.add s black
					   | L((a',_,s'),(b',_ ,s'')) -> 
					   let sol,black = 
					     if a'=a then 
					       if StringSet.mem s' black then
						 (sol,black) 
					       else s'::sol,StringSet.add s' black  
					     else sol,black in 
					    let sol,black = 
					     if b'=a then 
					       if StringSet.mem s''  black then
						 (sol,black) 
					       else s''::sol,StringSet.add s'' black 
					    else sol,black 
					    in 
					    sol,black
					   | _ -> sol,black )
					       
					 ([],StringSet.empty) 
					 restricted_blist in
					   
				     let bound_agent_list_same_class,
				       bound_agent_list_other_class = 
				       List.fold_left 
					 (fun 
					   (same,other) b 
					   ->
					     let f (a1,a2,a3,a5,a6) (same,other) = 						 let a4 = 
						   let rec aux l = 
						     match l with 
						       [] -> None 
						     | ((b1,b2,b3),(b4,b5,b6))::_ when (a1,a2,a3,a5,a6) = (b4,b5,b6,b2,b3) -> Some b1
						     | _::q -> aux q in
						   aux passives in
						 (match a4 with 
						   None -> (same,other)
						 | Some a4 when StringSet.mem a4 black -> (same,other)
						 | Some a4 -> 
						     if  not (List.exists (fun x -> x=(H(a4,a5),true)) rule.Pb_sig.injective_guard) then 
						       same,other
						     else
						       if a5<>a2
							 && 
						       String2Set.mem 
							 (a2,a3) rep.passing_sites
							 && 
						       String2Set.mem 
							 (a5,a6) rep.passing_sites
							   
						       then 
							 ((a4::same,other))
						       else
							 (same,(Some (a5,a6,a2,a3),a4)::other))
					       
					     in 
					     match b with 
					       AL((a1,a2,a3),(a5,a6)),true -> f (a1,a2,a3,a5,a6) (same,other)
					     | L((a1,a2,a3),(a4,a5,a6)),true -> 
						 let same,other = 
						   if a1=a then f (a1,a2,a3,a5,a6) (same,other)
						       else same,other in
						 let same,other = 
						   if a4=a then f (a4,a5,a6,a2,a3) (same,other) 
						   else same,other 
						 in same,other
					     | _ -> same,other )
					 (to_visit_same_class,to_visit_other_class)
					 restricted_blist in
				     let site_list = 
				       List.sort compare site_list in
				     let tp_list = 
				       try 
					 StringListMap.find 
					   site_list
					   (StringMap.find 
					      (specie_of_id a)  
					      agent_to_int_to_nlist) 
				       with Not_found -> 
					 unsafe_frozen 
					   "template 509" (fun () -> 
				       (try (print_string a;print_newline ();
					     print_string (specie_of_id a);
					     print_newline ();
					     List.iter 
					       print_string 
					       site_list)
				       with _ -> ());
					 raise Exit)
			       in
			       let (tp_list:int list) = 
				 List.fold_left 
				   (fun sol xx -> 
				     let (a,x,s,d) = 
				       try 
					 Intmap.find xx int_map 
				       with _ -> unsafe_frozen "template 511" (fun () -> raise Exit) 
				     in
				     let rec test_b s = 
				       match s with 
					 [] -> true 
				       | (b,bool)::q -> 
					   let b = b_of_var b in 
					  if 
					    try 
					      (BMap.find b bmap)=bool
					    with 
					      Not_found -> true 
					  then 
					    test_b q
					  else false
				     in
				     let test = test_b a in
				     if not test then sol 
				     else 
				       (xx::sol))
				   [] tp_list in
			       aux 
				 (List.fold_left
				    (fun sol x -> (guard,
				      bound_agent_list_same_class,
				      bound_agent_list_other_class,
				      StringSet.add a black,
				      x::prefix,
				      a::same_class_agent,
				      other_class)::sol) 
				    q
				    tp_list) 
				 sol
   end
		       in
		       let rep =
			 List.map 
			   (fun x -> 
			     List.filter 
				   (fun (a,b,c) -> b<>[]) 
				    x) 
				   (aux [None,[root],[],StringSet.empty,[],[],[]] []) in
		       (rule,agentset,blist,bmap,roots,rep))
		   x))
	      classes in 

	  let (get_denum:(string*string*string*string)->int list list) = 
	    let hash = Hashtbl.create 21 in
	    let f x = 
	      try 
		Hashtbl.find hash x
	      with 
		  Not_found -> 
		    let rec aux current sol = 
		      match current with 
			[] -> sol
		      |	([],stack)::q -> aux q (stack::sol) 
		      |	((a,s,a',s')::b,stack)::q ->
			  let ag1,s1,ag2,s2 = (a,s,a',s') in 
			  let tp = 
			    StringListMap.find 
			      [s] (StringMap.find a agent_to_int_to_nlist)
			  in
			  let q' =
			    List.fold_left
			      (fun q' n_tp -> 
				let (a,x,s,d) = Intmap.find n_tp int_map in
				if 
				  let rec aux l = 
				    match l with [] -> false
				    | t::q -> 
					begin
					  match b_of_var (fst t),snd(t) with AL((x,y,z),(t,u)),bool 
					    when x=ag1 && y=ag1 && z=s1 && t=ag2 && u = s2 -> bool
					  | _ -> aux q
					end
				  in aux a
				then 
				  
				  let b' = 
				    String4Set.fold 
				      (fun ((ag1,s1),(ag2,s2)) b' -> 
					if ag2 = a' && s'=s2  then b'
					else (ag2,s2,ag1,s1)::b')
				      d b 
				  in
				  (b',n_tp::stack)::q'
				else q')
			      q tp in
			  aux q' sol in
		    let rep = aux [[x],[]] [] in
		    (Hashtbl.add hash x rep;
		       rep)
		     in f in
	    let complete_tp_list tp = 
	      let root,target,map = 
		List.fold_left
		  (fun (root,target,map) tp ->
		    let (a,x,s,d) = Intmap.find tp int_map in
		    String4Set.fold 
		      (fun (y1,y2) (root,target,map) ->
			(String2Set.add y1 root,
			 String2Set.add y2 target,
		       String2Map.add y2 y1 map))
		      d (root,target,map))
		  (String2Set.empty,String2Set.empty,String2Map.empty) tp in
	      let target = String2Set.diff target root in
	      let (target2:int list list list) = 
		String2Set.fold
		  (fun y2 liste ->
		    let y1 = String2Map.find y2 map in
		    if String2Set.mem y1 rep.passing_sites &&
		      String2Set.mem y2 rep.passing_sites 
		    then 
		      (get_denum (fst y2,snd y2,fst y1,snd y1))::liste
		    else liste)
		  
		  target [] in
	      let sol = 
		let rec aux (l:int list list list) 
		    (sol:int list list) = 
		  match l with [] -> sol
		  | (t:int list list)::q -> 
		      aux q 
			(List.fold_left 
			   (fun liste (elt_t:int list) -> 
			     List.fold_left  
				   (fun sol b -> 
				     (elt_t@b)::liste)
			       liste sol)
			   [] 
			   (t:int list list)) in
		aux 
		  target2 
		  [tp] in 
	      sol in 
	    let classes = 
	      List.map 
		(fun x -> 
		  List.map 
		    (fun (xx,x,b,b2,d,rep) -> 
		      (xx,x,b,b2,d,
		       List.map 
			 (fun x -> 
			   List.map 
			     (fun (g,y,a) -> 
			       (g,complete_tp_list y,a)) x)
			 rep))
		    x)
		classes in 
	    let expr_of_subcomponent  (a,_,b) = 
	      List.fold_left 
		(fun expr b -> 
		  Plus(expr,
		       (match a 
		       with 
			 None -> Var (List.hd (hash_tp_list  true b  ))
		       | Some a -> 
			   let d = get_denum a in
				 Div (Plus(Eps,Var (List.hd (hash_tp_list true b))), 
				      List.fold_left 
					(fun expr d -> 
					  Plus(expr,(Var (List.hd (hash_tp_list true  d)))))
					(Eps) 
					d))))
		      (Const 0) b in
	    let expr_of_case  z = 
	      List.fold_left 
		(fun expr (a,(b:int list list),c) -> 
		  Mult(expr,expr_of_subcomponent  (a,c,b)))
		(Const 1) z in
	    let expr_of_classe   rep = 
	      List.fold_left 
		(fun cost z ->
		      Plus(cost,
			   expr_of_case  z))
			(Const 0) rep in
	    let classes  =
	      List.map 
		(fun x
		  -> 
		    x,
		      (simplify_expr
			 (List.fold_left
			    (fun cost (_,_,_,_,_,rep) -> 
			      
			      Mult(cost,expr_of_classe rep))
			    
			    (Const 1) 
			    x
			    )))
		classes
 
	    in 
	    let _ = 
	      List.iter 
		(fun (x,expr) -> 
		  let _ = 
		    List.iter 
		      (fun (xx,x,b,b2,d,rep) -> 
			 let _ = print_string2 "k(" in
			 let _ = print_string2 (List.hd xx.Pb_sig.labels).Pb_sig.r_id in
			 let _ = print_string2 ") := " in
			 let _ = print_expr print_string2 print_int2 print_float2 (simplify_expr (Mult(Constf(List.hd xx.Pb_sig.labels).Pb_sig.r_simplx.Rule.kinetics,expr))) in
			 let _ = print_newline2 () in ()) 
		      x in ())
		classes 
	    in
	    classes) 
	system in 
    let rep = 
      List.map 
	(fun rs -> 
	    
	    let prod = Intmap.empty in
	    let fadd i k expr prod = 
	      List.fold_left 
		(fun prod i -> 
		  let old = 
		    try 
		      Intmap.find i prod
		    with Not_found -> ([]) in
		  Intmap.add i ((k,expr)::old) prod)
		prod i 
	    in 
	    
	    let prod = 
	      List.fold_left  
		(fun prod (x,expr) -> 
		  if control.remove = []
			&& control.uncontext_update = []
			&& List.for_all (fun (b,bool) -> match b with H _ -> not bool | _ -> true) control.context_update
			
		    then 
		      let combi_list = 
			List.fold_left 
			  (fun prefix_list (xx,x,b,b2,d,rep) -> 
			    List.fold_left
			      (fun liste t -> 
				List.fold_left  
				  (fun liste prefix -> 
				    ((xx,x,b,b2,d,t)::prefix)::liste)
				    liste prefix_list)
			      [] rep)
		      [[]] x  in 
		      let denum = 
			List.fold_left
			  (fun denum combi_case -> 
			    Plus(denum,
				 List.fold_left 
				   (fun terme (xx,x,b,b2,d,rep) -> 
				     Mult(terme,expr_of_case rep))
				   (Const 1) combi_case 
				 ))
			  Eps combi_list in
		      let prod = 
			List.fold_left 
			  (fun prod combi_case -> 
			    List.fold_left 
			      (fun prod (xx,x,b,b2,d,rep) -> 
				let filter_context_update  context_update agents = 
				List.fold_left 
				(fun sol (b,bool) ->
				  match b,bool with 
				    H(a,a'),_ ->  sol
				  |	L((a,a',b'),(c,c',d')),_ -> 
				      let sol  =
					if StringSet.mem a agents then 
				      (AL((a',a',b'),(c',d')),bool)::sol 
					else
					  sol in 
				      let sol = 
				    if StringSet.mem c agents then 
				      (AL((c',c',d'),(a',b')),bool)::sol 
				    else 
				      sol in
				      sol
				  |	AL((a,a',b'),(c,d)),_ -> 
				      if StringSet.mem a agents then 
					(AL((a',a',b'),(c,d)),bool)::sol 
				      else sol
				  |	B((a,a',b)),_ -> 
				      if StringSet.mem a agents then 
					(B(a',a',b),bool)::sol
				      else
					sol 
				  |	M((a,a',b),m),_ -> 
				      if StringSet.mem a agents then 
					(M((a',a',b),m),bool)::sol
				      else sol
				  |	_ -> sol) [] context_update in
			  if 
			    filter_context_update control.context_update x <> []
			  then
			    List.fold_left 
			      (fun prod case -> 
				List.fold_left 
				  (fun prod (g,x,ag) ->
				    let context_update = 
				      filter_context_update control.context_update (List.fold_left (fun sol x -> StringSet.add x sol) StringSet.empty ag) in
				    if context_update = []
				    then prod 
				    else 
				      List.fold_left 
					(fun prod c -> 
					  let consume = c in
					  let kyn = Mult(Constf(List.hd xx.Pb_sig.labels).Pb_sig.r_simplx.Rule.kinetics,(Mult(Div(
							 Plus(Eps,expr_of_case case),
							 denum),expr))) in
					  let product = 
					    begin
					      let fadd x b bool map = 
						let old = 
						  try
						    StringMap.find x map 
						  with Not_found -> BMap.empty in
						StringMap.add x 
						  (match b with 
						  | M((_,y,_),_) 
						  | AL((_,y,_),_) 
						  | B(_,y,_) when y=x -> BMap.add b bool old
						  | _ -> old)
						  map  in
					      let bmap = StringMap.empty in
					      let bmap = 
						List.fold_left 
						  (fun bmap tp_i -> 
						    let (a,x,s,int) = Intmap.find tp_i int_map in
						    let bmap = 
						      List.fold_left 
							(fun bmap  (b,bool) ->
							  fadd x (b_of_var b) bool bmap)
							bmap a in
						    let bmap = 
						      List.fold_left 
							(fun map (b,bool) -> 
							  fadd x b bool map)
							bmap context_update in
						    bmap)
						  bmap c in
					     
						StringMap.fold 
						  (fun x bmap sol ->
						    let stringblist = 
						      (x,List.sort compare 
							 (BMap.fold (fun b bool l -> (b,bool)::l) bmap []))
						    in
						    (StringBListMap.find stringblist blist_to_template)::sol)
						  bmap [] 
					       
					    end
					  in
					  let prod = 
					    fadd 
					      (hash_tp_list false consume)
					      
					      ((-1)) kyn 
					      
					    prod in 
					  let prod = 
					    fadd 
					      (hash_tp_list false product)
					      (1) kyn prod in 
					  prod ) prod  x)
				  prod 
				  case)
			      prod rep
			  else
			    prod
				
			  
			    )
			prod  x) 
			  prod combi_list
		      in prod 
		  else 
		    prod)
		    
		prod classes

		    in 
	  
(classes,prod)) 
	system  in 
    let _ = dump int_map  in
    let merge_prod = 
      List.fold_left 
	(fun prod (classe,prod') -> 
	  Intmap.map2 (fun i x -> x) (fun i x -> x) (fun i x y -> x@y)
	    prod prod')
	Intmap.empty activity in 
    let _ = dump_prod merge_prod in 
    let _ = 
      match chan with None -> ()
      |	Some chan -> close_out chan in
    let _ = 
      match chan2 with None -> () 
      |	Some chan2 -> close_out chan2 in 

    (*let sites_to_var = 
      List.fold_left 
	(fun map (a,b,tp) -> 
	  List.fold_left 
	    (fun map (s,x) ->
	      ) map tp)
	String2Set.empty  in*)
    Some (rep,activity),(l,m)

end
